name: CD - Deploy to Development

on:
  push:
    branches: [develop]
  workflow_dispatch:

env:
  OCI_REGION: ${{ vars.OCI_REGION }}
  REGISTRY:  ${{ vars.OCI_REGISTRY }}
  REGISTRY_NAMESPACE: ${{ secrets.REGISTRY_NAMESPACE }}
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}
  OKE_CLUSTER_ID: ${{ secrets.OKE_CLUSTER_ID }}
  OCI_VAULT_ID: ${{ vars.OCI_VAULT_ID }}  # Optional: for External Secrets integration
  EXTERNAL_SECRETS_ENABLED: ${{ vars.EXTERNAL_SECRETS_ENABLED }}
  NAMESPACE: dev

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    name: Build and Push to OCIR
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup OCI CLI
        run: |
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install.sh
          chmod +x install.sh
          ./install.sh --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Configure OCI credentials
        run: |
          export OCI_CLI_SUPPRESS_FILE_PERMISSIONS_WARNING=True
          mkdir -p ~/.oci
          echo "[DEFAULT]" > ~/.oci/config
          echo "tenancy=${{ secrets.OCI_TENANCY_OCID }}" >> ~/.oci/config
          echo "user=${{ secrets.OCI_USER_OCID }}" >> ~/.oci/config
          echo "fingerprint=${{ secrets.OCI_FINGERPRINT }}" >> ~/.oci/config
          echo "region=${{ env.OCI_REGION }}" >> ~/.oci/config
          echo "key_file=~/.oci/key.pem" >> ~/.oci/config
          echo "${{ secrets.OCI_PRIVATE_KEY }}" > ~/.oci/key.pem
          chmod 600 ~/.oci/key.pem
          oci setup repair-file-permissions --file ~/.oci/config

      - name: Login to Oracle Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.OCIR_USERNAME }}
          password: ${{ secrets.OCIR_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.REGISTRY_NAMESPACE }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=dev-
            type=raw,value=dev-latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}

      - name: Sign image with Cosign
        run: |
          echo "Instalando Cosign..."
          curl -LO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign

          echo "Assinando imagem..."
          # cosign sign --key cosign.key ${{ env.REGISTRY }}/${{ env.REGISTRY_NAMESPACE }}/${{ env.IMAGE_NAME }}:${{ steps.meta.outputs.version }}

  deploy-to-dev:
    name: Deploy to OKE Development
    runs-on: ubuntu-latest
    needs: build-and-push
    environment:
      name: development
      url: https://dev.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup OCI CLI
        run: |
          curl -L https://raw.githubusercontent.com/oracle/oci-cli/master/scripts/install/install.sh -o install.sh
          chmod +x install.sh
          ./install.sh --accept-all-defaults
          echo "$HOME/bin" >> $GITHUB_PATH

      - name: Configure OCI credentials
        run: |
          export OCI_CLI_SUPPRESS_FILE_PERMISSIONS_WARNING=True
          mkdir -p ~/.oci
          echo "[DEFAULT]" > ~/.oci/config
          echo "tenancy=${{ secrets.OCI_TENANCY_OCID }}" >> ~/.oci/config
          echo "user=${{ secrets.OCI_USER_OCID }}" >> ~/.oci/config
          echo "fingerprint=${{ secrets.OCI_FINGERPRINT }}" >> ~/.oci/config
          echo "region=${{ env.OCI_REGION }}" >> ~/.oci/config
          echo "key_file=~/.oci/key.pem" >> ~/.oci/config
          echo "${{ secrets.OCI_PRIVATE_KEY }}" > ~/.oci/key.pem
          chmod 600 ~/.oci/key.pem
          oci setup repair-file-permissions --file ~/.oci/config

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.34.1'

      - name: Configure kubectl for OKE
        run: |
          mkdir -p $HOME/.kube
          oci ce cluster create-kubeconfig \
            --cluster-id ${{ env.OKE_CLUSTER_ID }} \
            --file $HOME/.kube/config \
            --region ${{ env.OCI_REGION }} \
            --token-version 2.0.0 \
            --kube-endpoint PUBLIC_ENDPOINT
          chmod 600 $HOME/.kube/config

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Create namespace if not exists
        run: |
          if kubectl get namespace ${{ env.NAMESPACE }} > /dev/null 2>&1; then
            echo "Namespace exists, adding Helm labels and annotations..."
            kubectl label namespace ${{ env.NAMESPACE }} app.kubernetes.io/managed-by=Helm environment=dev --overwrite
            kubectl annotate namespace ${{ env.NAMESPACE }} meta.helm.sh/release-name=myapp meta.helm.sh/release-namespace=${{ env.NAMESPACE }} --overwrite
          else
            echo "Creating namespace with Helm labels..."
            kubectl create namespace ${{ env.NAMESPACE }}
            kubectl label namespace ${{ env.NAMESPACE }} app.kubernetes.io/managed-by=Helm environment=dev
            kubectl annotate namespace ${{ env.NAMESPACE }} meta.helm.sh/release-name=myapp meta.helm.sh/release-namespace=${{ env.NAMESPACE }}
          fi

      - name: Create OCIR pull secret
        run: |
          kubectl create secret docker-registry ocir-secret \
            --docker-server=${{ env.REGISTRY }} \
            --docker-username=${{ secrets.OCIR_USERNAME }} \
            --docker-password=${{ secrets.OCIR_TOKEN }} \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        run: |
          helm upgrade --install myapp ./helm/myapp \
            --namespace ${{ env.NAMESPACE }} \
            --set externalSecrets.enabled=${{ env.EXTERNAL_SECRETS_ENABLED }} \
            --set image.repository=${{ env.REGISTRY }}/${{ env.REGISTRY_NAMESPACE }}/${{ env.IMAGE_NAME }} \
            --set image.tag=${{ needs.build-and-push.outputs.image-tag }} \
            --set environment=dev \
            --set externalSecrets.vaultId=${{ env.OCI_VAULT_ID }} \
            --set externalSecrets.region=${{ env.OCI_REGION }} \
            --values ./helm/myapp/values-dev.yaml \
            --wait \
            --timeout 5m \
            --atomic

      - name: Verify deployment
        run: |
          DEPLOYMENT_NAME=$(kubectl get deployments -n ${{ env.NAMESPACE }} -l app.kubernetes.io/name=myapp -o jsonpath='{.items[0].metadata.name}')
          echo "Deployment name: $DEPLOYMENT_NAME"
          kubectl rollout status deployment/$DEPLOYMENT_NAME -n ${{ env.NAMESPACE }} --timeout=5m
          kubectl get pods -n ${{ env.NAMESPACE }}
          kubectl get services -n ${{ env.NAMESPACE }}

      - name: Run smoke tests
        run: |
          echo "Aguardando pods estarem ready..."
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=myapp -n ${{ env.NAMESPACE }} --timeout=120s || true

          echo "Status dos pods:"
          kubectl get pods -n ${{ env.NAMESPACE }} -l app.kubernetes.io/name=myapp

          echo "Executando smoke tests..."
          SERVICE_NAME=$(kubectl get svc -n ${{ env.NAMESPACE }} -l app.kubernetes.io/name=myapp -o jsonpath='{.items[0].metadata.name}')
          echo "Service name: $SERVICE_NAME"

          # Tenta smoke test, mas não falha o deploy se não funcionar
          kubectl run smoke-test --image=docker.io/curlimages/curl:latest --rm -i --restart=Never -n ${{ env.NAMESPACE }} --timeout=30s -- \
            curl -f -v http://${SERVICE_NAME}:80/health || echo "Warning: Smoke test failed, check application logs"

      - name: Get deployment info
        if: always()
        run: |
          echo "=== Deployment Status ==="
          kubectl get deployments -n ${{ env.NAMESPACE }}
          echo "=== Pods ==="
          kubectl get pods -n ${{ env.NAMESPACE }}
          echo "=== Services ==="
          kubectl get services -n ${{ env.NAMESPACE }}
          echo "=== Recent Events ==="
          kubectl get events -n ${{ env.NAMESPACE }} --sort-by='.lastTimestamp' | tail -20

  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-dev]
    if: always()

    steps:
      - name: Deployment summary
        run: |
          echo "## Deployment to Development" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.deploy-to-dev.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: Development" >> $GITHUB_STEP_SUMMARY
